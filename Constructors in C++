Output of following program?

#include<iostream>
using namespace std;
class Point {
    Point() { cout << "Constructor called"; }
};
 
int main()
{
   Point t1;
   return 0;
}
Run on IDE
(A) Compiler Error
(B) Runtime Error
(C) Constructor called


Answer: (A) 

Explanation: By default all members of a class are private. Since no access specifier is there for Point(), it becomes private and it is called outside the class when t1 is constructed in main. 









What is the output of following program?

#include <iostream>
using namespace std;
 
class Point
{
    int x, y;
public:
   Point(const Point &p) { x = p.x; y = p.y; }
   int getX() { return x; }
   int getY() { return y; }
};
 
int main()
{
    Point p1;
    Point p2 = p1;
    cout << "x = " << p2.getX() << " y = " << p2.getY();
    return 0;
}
Run on IDE
(A) x = garbage value y = garbage value
(B) x = 0 y = 0
(C) Compiler Error


Answer: (C) 

Explanation: There is compiler error in line “Point p1;”. The class Point doesn’t have a constructor without any parameter. If we write any constructor, then compiler doesn’t create the default constructor.

It is not true other way, i.e., if we write a default or parameterized constructor, then compiler creates a copy constructor. See the next question.





Predict the output of following program.

#include<iostream>
#include<stdlib.h>
using namespace std;
 
class Test
{
public:
   Test()
   { cout << "Constructor called"; }
};
 
int main()
{
    Test *t = (Test *) malloc(sizeof(Test));
    return 0;
}
Run on IDE
(A) Constructor called
(B) Empty
(C) Compiler Error
(D) Runtime error


Answer: (B) 


     NEW	                                                                      MALLOC
calls constructor	                                                    doesnot calls constructors
It is an operator	                                                       It is a function
Returns exact data type	                                                     Returns void *
on failure, Throws	                                                      On failure, returns NULL
Memory allocated from free store	                                    Memory allocated from heap
can be overridden	                                                       cannot be overridden
size is calculated by compiler	                                        size is calculated manually




#include <iostream>
using namespace std;
 
class Test
{
public:
      Test() { cout << "Hello from Test() "; }
} a;
 
int main()
{
    cout << "Main Started ";
    return 0;
}
Run on IDE
(A) Main Started
(B) Main Started Hello from Test()
(C) Hello from Test() Main Started
(D) Compiler Error: Global objects are not allowed


Answer: (C) 

Explanation: Output is

Hello from Test() Main Started
There is a global object ‘a’ which is constructed before the main functions starts, so the constructor for a is called first, then main()’ execution begins. 

