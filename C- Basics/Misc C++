Inline functions are useful when
(A) Function is large with many nested loops
(B) Function has many static variables
(C) Function is small and we want to avoid function call overhead.
(D) None of the above


Answer: (C) 

Explanation: Inline functions are generally used in place of small macros. They are substitute to macros and better than macros. See following for details.
http://en.wikipedia.org/wiki/Inline_function#Comparison_with_macros



#include<iostream>
using namespace std;
int x = 1;
void fun()
{
    int x = 2;
    {
        int x = 3;
        cout << ::x << endl;
    }
}
int main()
{
    fun();
    return 0;
}
Run on IDE
(A) 1
(B) 2
(C) 3
(D) 0


Answer: (A) 

Explanation: The value of ::x is 1.

The scope resolution operator when used with a variable name, always refers to global variable.





#include<iostream>
using namespace std;
 
union A {
  int a;
  unsigned int b;
  A() { a = 10; }
  unsigned int getb() {return b;}
};
 
int main()
{
    A obj;
    cout << obj.getb();
    return 0;
}
Run on IDE
(A) Compiler Error: union can’t have functions
(B) Compiler Error: can’t access private members of A
(C) 10
(D) garbage value


Answer: (C) 

Explanation: Like struct and class, union can have methods. Like struct and unlike class, members of union are public by default.

Since data members of union share memory, the value of b becomes same as a.







